                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          [{"title":"android 无线调试","url":"/2022/05/31/android-无线调试/","content":"传统 APP 调试方法都是 usb 有线调试，这种方式不仅限制的 APP 测试的有线范围，也同样影响开发效率APP 无线调试要确保手机和电脑在同一局域网下，这样的两台设置才能建立有线的 ADB 连接下载 ADB 测试插件连接 APP 工具使用 USB 连接手机出现下提示说明设备连接成功开启无线连接接下来需要知道手机在局域网中的 IP,一般手机可以在设置 → 关于手机 →IP 中查看到当端口或者服务被阻塞、占用时，可以杀死进程进行重启APP 文件读取工具用于 PC 端直接操作移动端文件，在做一下文件管理功能时十分有效安装插件","tags":["App应用"],"categories":["Java"]},{"title":"icestark微前端所做的事","url":"/2022/03/21/icestark微前端所做的事/","content":"icestark 是一个面向大型系统的微前端解决方案项目初始化初始化主应用初始化子应用兼容性现代浏览器和 IE11 及以上icestark 与 qiankun 的爱恨情仇icestark 与 qiankun 同为阿里开发的微前端方案，其中就存在着很多故事，qiankun 是基于 single-spa 而封装了隔离及共享机制的框架，其简化了 single-spa 的相关生命周期，并且提供了沙箱隔离机制及共享机制。icestark 是淘系团队的一个全流程前端框架，拥有强大的生态系统。当然其中两者也存在着弊端qiankun:对于混合微前端方式不友好，如跨标签页、iframe 内嵌通讯对于事件不能自定义，单一应用只有一个回调可用不可剥离微前端框架icestark:window 对象托管 store 不安全，易被数据劫持和篡改相关文件githubicestark","tags":["工具"],"categories":["JavaScript"]},{"title":"前端（SSR）服务端渲染-探究","url":"/2022/03/09/前端（SSR）服务端渲染-探究/","content":"SSR 是 Service Side Render 简称，页面上的内容是通过服务端渲染生成，游览器直接显示服务端返回的 HTML 就可以了。一、 使用 SSR 的利弊SSR 的优势1.更利于 SEO2.更利于首屏渲染SSR 的局限1.服务端压力较大2.开发条件受限3.学习成本相对较高二、使用架构Vue 可使用 Nuxt.js基于 Vue.js自动代码分层服务端渲染强大的路由功能，支持异步数据静态文件服务ES6/ES7 语法支持打包和压缩 JS 和 cssHTML 头部标签管理本地开发支持热加载集成 ESLint支持各种样式预处理器： SASS、LESS、 Stylus 等等React 可使用 Next.js直观的、 基于页面 的路由系统（并支持 动态路由）预渲染。支持在页面级的 静态生成 (SSG) 和 服务器端渲染 (SSR)自动代码拆分，提升页面加载速度具有经过优化的预取功能的 客户端路由内置 CSS 和 Sass 的支持，并支持任何 CSS-in-JS 库开发环境支持 快速刷新利用 Serverless Functions 及 API 路由 构建 API 功能完全可扩展","tags":["技术动态"],"categories":["JavaScript"]},{"title":"PC小程序的认真一拳","url":"/2021/07/11/PC小程序的认真一拳/","content":"自从微信 PC 端 2.7.0 版本以后，PC 端开始支持打开小程序，随之而来的技术的进步总是有问题的产生，PC 端与移动端显而易见的有了兼容性的问题。PC 端小程序小程序的跨端功能是它的优势，正是因为它的跨度功能导致小程序在各端总会出现一些不能兼容各端功能的问题，不仅是移动端和 PC 端，还有 IOS 和 Android 端也会时常有问题发生。差异PC 端和移动端的主要差异在于微信 API 对后台系统的调用，所以框架上就有了不同：PC 端现在最流行框架 vue 开发,但 vue 不兼容 ie8 以下,,,,,,jquery 是没有兼容性,专门兼容 ie8，而移动端开发考虑的是更多的是手机兼容性,因为目前不管是 android 手机还是 IOS 手机,一般浏览器使用都是 webkit 内核;一般 pc 端使用 jquery,,移动端一般使用 zepto,因为移动端的流量还是比较重要,所以引入的资源能小则小.问题案例PC 端小程序图片上传在图片上传过程中小程序无法获取到 PC 端中的图片地址，导致图片无法获取案例解决方案这个问题的主要原因是在于 wx.uploadFile 中定义的 Content-type","tags":["工具"],"categories":["小程序"]},{"title":"前端如何掌控动态路由","url":"/2021/07/11/前端如何掌控动态路由/","content":"背景复杂的权限在前端不方便控制，将路由保存到后端，经过后端鉴权后返回相应的路由。umi 版本: 2.x注意该方法适用于 umi 3.x，但是需要注意，patchRoutes 的参数与 2.x 不同。方案使用 umi 提供的 运行时配置 功能，结合 patchRoutes 和 render 接口，动态修改路由。在项目根目录创建 app.js 文件，该文件为 umi 的运行时配置文件。config 目录下以及 .umirc.js 文件都是编译时配置。编写 patchRoutes 和 render 方法。注意render 函数在 patchRoutes 之前执行，所以要在 render 中获取后端返回的路由数据。","tags":["技术动态"],"categories":["JavaScript"]},{"title":"Taro特色UI vant-ui","url":"/2021/07/11/Taro特色UI-vant-ui/","content":"引入 vant-ui 到 taro 中配置 vant-ui 中项目的尺寸的转换将下列代码加入项目的 config/index.js 文件中配置小程序原生组件文件由于 vant 的有些组件依赖于小程序的原生组件，所以要对这些组件进行本地文件的添加下载地址下载好文件后添加项目下的 component 文件夹下将下列代码加入项目的 config/index.js 文件中引用 vant 组件首先需要在 app 的 config 或页面的 config 文件中配置 usingComponents 字段使用 vant 组件ReactVue注意：如果组件的某些属性在 vant 文档里写着带有默认值 true，在 Taro 中使用时仍然需要显式设置为 true。","tags":["工具"],"categories":["小程序"]},{"title":"小程序反编译","url":"/2021/03/11/小程序反编译/","content":"安装环境nodejs 运行环境，这是反编译脚本所需运行环境。下载 node下载反编译工具进入项目目录如果没有安装 cnpm,可以下载模拟器获取小程序.pkg 文件夜神、MuMu 等等都可以Mac 上推荐 MuMu，夜神在 Mac 上体验好差模拟器开启 ROOT 权限登录微信，打开小程序进入微信小程序暂存文件目录一般情况下一个小程序对应一个 wxapkg 文件,将 wxapkg 文件复制 pc 端中反编译小程序反编译 wxapkg 包使用微信开发工具导入编译项目","tags":["工具"],"categories":["小程序"]},{"title":"尾调用和尾递归","url":"/2021/03/10/尾调用和尾递归/","content":"讲尾调用和尾递归优化之前，需要知道了函数执行栈。执行栈执行栈，也叫调用站，具有栈存储的特性LIFO（Last in,First out 后进先出）结构，用于存储在代码执行过程中创建的所有执行上下文。在代码执行过程中每发生函数调用时，引擎都会为函数创建一个新的执行上下文并 PUSH 到当前执行栈的栈顶。当函数运行完成后，将对应的执行上下文从执行栈中 POP 出，上下文的控制权将转到当前执行栈的下一个执行上下文。尾调用尾调用:是指执行某个函数时，最后异步是一个函数调用，并且被调用函数的返回值直接被当前函数返回。尾调用优化函数调用时会在内存中产生一个“调用记录”，又称调用帧。尾调用由于是函数最后一步操作，内调用会直接取代外层调用，形成一次直接的函数调用。尾递归递归:函数调用自身。尾递归:在尾部直接调用自身的递归函数。尾递归，比线性递归(普通递归)多一个参数且只有一个参数，这个参数是上一次调用函数得到的结果；所以，关键点在于，尾递归每次调用都在收集结果，避免了线性递归不收集结果只能依次展开消耗内存的坏处比线性递归多一个参数，这个参数是上一次调用函数得到的结果；递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。尾递归优化尾递归的优化是是 O(n)到 O(1)的，将多出的一个遍历调用转变为一次函数调用普通的递归，算到最后一步的时候，计算机内存里存储的值是 5 ＋ 4 ＋ 3 ＋ 2 ＋ sum(1)，这里是 4 个数字，和一个需要计算的函数 sum()，然后再把这 5 个数字加起来，得出结果 15。尾递归，算到最后一步的时候，计算机内存里存储的值是 14+sum(1)，这里是 1 个数字，和一个需要计算的函数 sum()。","tags":["算法"],"categories":["JavaScript"]},{"title":"网路安全之HSTS","url":"/2021/03/04/网路安全之HSTS/","content":"很多人知道 301、302 状态码，但是几乎没有了解过 303、307 的状态码，有幸今天在淘宝首页看见了 307 状态，所以便想了解其使用。中间人劫持（302 使用）当我们在游览器中输入 URL 的时候，游览器默认请求端口是 80，但 https 请求是通过 443 端口进行数据传输的，那怎么办呢，这时我们就要在游览器和服务器之间进行一个中间人劫持的行为，首先中间人会劫持（或者直接占用）80 端口，当游览器有请求过来时会模拟正常的 https 向服务器进行请求数据，然后在通过 80 端口返回给用户。http 请求（320 重定向）中间人劫持只要能够劫持你的网络，比如路由劫持、DNS 劫持，就可以作为中间人注入代码、替换广告。这种劫持出现在两种情况下：用户没有通过准确的方式访问页面，除非输入 // ，否则浏览器默认以 http 方式访问。HTTPS 页面的链接中包含 http，这个 http 页面可能被劫持启用 HSTSHSTS，HTTP Strict Transport Security，简单说就是强制客户端使用 HTTPS 访问页面。其原理就是：在服务器响应头中添加 Strict-Transport-Security，可以设置 max-age用户访问时，服务器种下这个头下次如果使用 http 访问，只要 max-age 未过期，客户端会进行内部跳转，可以看到 307 Redirect Internel 的响应码变成 https 访问源服务器启用 HSTS 不仅仅可以有效防范中间人攻击，同时也为浏览器节省来一次 302/301 的跳转请求，收益还是很高的。其实就是通过 head 头的设置将 http 请求强制转换为 https 请求。307 状态码在 GET、HEAD 这些幂等的请求方式上，302、303、307 没啥区别，而对于 POST 就不同了，大部分浏览器 都会 302 会将 POST 请求转为 GET，而 303 是规范强制规定将 POST 转为 GET 请求，请求地址为 header 头中的 Location，307 则不一样，规范要求浏览器继续向 Location 的地址 POST 内容。而在 HSTS 中，307 可以被缓存，缓存时间根据 max-age 而定，一般建议缓存 1 年甚至更长。HSTS 存在的坑纯 IP 的请求，HSTS 没法处理，比如 http://2.2.2.2 ， 即便响应头中设置了 STS，浏览器也不会理会（未测试）HSTS 只能在 80 和 443 端口之间切换，如果服务是 8080 端口，即便设置了 STS，也无效（未测试）如果浏览器证书错误，一般情况会提醒存在安全风险，然是依然给一个链接进入目标页，而 HSTS 则没有目标页入口，所以一旦证书配置错误，就是很大的故障了如果服务器的 HTTPS 没有配置好就开启了 STS 的响应头，并且还设置了很长的过期时间，那么在你服务器 HTTPS 配置好之前，用户都是没办法连接到你的服务器的，除非 max-age 过期了。","tags":["HTML5"],"categories":["游览器协议"]},{"title":"css -webkit-box-reflect 倒影特效","url":"/2021/03/03/css-webkit-box-reflect-倒影特效/","content":"webkit-box-reflect 是一个非常有意思的属性，它让 CSS 有能力像镜子一样，反射我们元素原本绘制的内容上一次写它，它的兼容性还非常非常的惨淡，但是到今天，虽然还是一个 Non-standard 的语法，但是兼容性已经大有改观。截止至 2021-02-19，它的兼容性已经达到了 91.02%，看看CANIUSE -webkit-box-reflect:基本用法below 可以是 below | above | left | right 代表下上左右，也就是有 4 个方向可以选。设置倒影距离在方向后面，还可以接一个具体的数值大小，表示倒影与原元素间的距离。加上 10px 之后，倒影与原元素间将间隔 10px设置倒影虚实还有一个非常重要的功能，就是方位后面，还能再设置一个渐变值，利用这个渐变值，可以实现倒影的一个虚化效果，这一点非常重要。使用 -webkit-box-reflect 创造艺术图案从最深处的子字节绘制一张图片，一层叠一层进行多次的倒影翻转,就会从进过多次对称显示为","tags":["HTML5"],"categories":["css"]},{"title":"图片规范","url":"/2021/03/01/图片规范/","content":"图片格式常见的图片格式有 GIF、PNG8、PNG24、JPEG、WEBP，根据图片格式的特性和场景需要选取适合的图片格式。内容图内容图多以商品图等照片类图片形式存在，颜色较为丰富，文件体积较大优先考虑 JPEG 格式，条件允许的话优先考虑 WebP 格式尽量不使用 PNG 格式，PNG8 色位太低，PNG24 压缩率低，文件体积大背景图背景图多为图标等颜色比较简单、文件体积不大、起修饰作用的图片PNG 与 GIF 格式，优先考虑使用 PNG 格式,PNG 格式允许更多的颜色并提供更好的压缩率图像颜色比较简单的，如纯色块线条图标，优先考虑使用 PNG8 格式，避免不使用 JPEG 格式图像颜色丰富而且图片文件不太大的（40KB 以下）或有半透明效果的优先考虑 PNG24 格式图像颜色丰富而且文件比较大的（40KB - 200KB）优先考虑 JPEG 格式条件允许的，优先考虑 WebP 代替 PNG 和 JPEG 格式图片大小PC 平台单张的图片的大小不应大于 100KB。移动平台单张的图片的大小不应大于 50KB图片质量上线的图片都应该经过压缩处理，压缩后的图片不应该出现肉眼可感知的失真区域60 质量的 JPEG 格式图片与质量大于 60 的相比，肉眼已看不出明显的区别，因此保存 JPEG 图的时候，质量一般控制在 60，若保真度要求高的图片可适量提高到 80，图片大小控制在 200KB 以内图片引入测试内容图应该写上表明图片尺寸的占位图，可以用线上占位图生成服务HTML 中图片引入不需添加 width、height 属性，alt 属性应该写上[强制]图片缺省：[强制]机械[强制]其他[强制]背景图缺省：对应缺省图CSS 中图片引入不需要引号CSS Sprites特点减少请求数加速图片的显示维护更新成本大更多的内存消耗，特别是大体积或有过多空白的 Sprites 图图片渗漏，相邻的不需展示的图片有可能出现在展示元素中，特别是在高清设备移动设备上建议适合使用频率高更新频率低的小图标尽量不留太多的空白体积较大的图片不合并确保要合并的小图坐标数值和合并后的 Sprites 图尺寸均为偶数Data URIs（base64 编码）特点减少请求数转换文件体积大，大约比原始的二进制大 33%IE6 / IE7 不支持图片显示相对较慢，需要更多的 CPU 消耗建议适合更新频率高的小图片，如某些具备自定义功能的标题 icon 等转换成 Base64 编码的图片应小于 2KB移动端不使用 Base64 编码要兼容 IE6/IE7 的不使用图片地址本地图片地址存储规范统一以绝对路径 import 图片引入路径oss 图片上传规小程序主包中尽量使用网络图片，经统计 93%的图片内存占用在 3KB 以下（主包及子包），所以图片上传资源的标准个人建议以 2KB 为标准oss 图片引用地址：https://d.zhgcloud.com根据图片存储路径进行 URL 的拼接例如：图片图片使用规范所有图片必须经过一定的压缩和优化才能发布[强制]命名全部用小写英文字母,数字, _ 的组合，其中不得包含汉字,空格,特殊字符。（模块_页面_功能@1/2/3.图片格式），默认使用 2 倍图时不添加倍数规范。尽量用易懂的词汇, 便于团队其他成员理解; 另, 命名分头尾两部分, 用下划线隔开尽量避免使用半透明的 png 图片倍图使用倍图使用在 pc 端并不常见，但在移动端的使用就尤为重要。一倍图：1x 的图标用于 1:1 的屏幕，非视网膜屏，例如 iPhone 3GS、（/20140414DEL/ //早期 iPhone 4）非视网膜屏的众多 iPad 等。二倍图：2x 的图标用于 1:2 的屏幕，大部分视网膜屏，机型如（/20140414ADD/ iPhone 4、）iPhone 4S、iPhone 5、iPhone 5s、iPhone 6、iPad with Retina 及后续的视网膜屏 iPad 等。三倍图：3x 的图标目前应用于 1:3 的屏幕，即 iPhone 6Plusiconiconfont 使用定义共享项目，上传 iconfont 的 icon 使用，统一管理每个项目写 icon 资源使用使用场景：项目中使用的 icon 不符合 antd icon 的使用方式或无法使用 antd icon 及 css 样式达到项目显示效果时，使用 iconfont 自定义 icon 进行显示。antd icon 使用我们主要使用 antd_icon 的尺寸、颜色、类型属性创建可复用的 icon 组件（固定使用参数）统计 icon 的使用，减少 antd icon 与 iconfont 的 icon 重复图片打包小程序：quality 设置压缩图片的品质，建议设置为 95-100。minFileSize 设置多大以上的图片才压缩，单位是比特,建议为 1024。test 设置那里的图片才压缩，这里的路径是打包后的路径，如果打包后图片存放的文件夹是 images","tags":["工具"],"categories":["代码格式化"]},{"title":"VSCode工作区配置-代码统一格式化","url":"/2020/12/25/VSCode工作区配置-代码统一格式化/","content":"问题原因：解决前端项目格式化文件不统一问题小程序使用 prettier 后报错：解决问题可以直接修改 prettier 配置，但其他项目可能用不到其中的配置，这样提高了格式化配置项的耦合性，所以我们可以通过配置不同的项目格式化规范来减少我的配置次数。VSCode 层次关系系统默认设置（不可修改）-用户设置-工作区设置-文件夹设置。后者的设置会覆盖前者的设置，若没有设置某一项，将继续使用前者的设置。用户设置即全局设置，用户自行设定好后，每次打开 VSCode 即使用的此设定，若某项无设定即使用默认设置。工作区设置即工作环境设置，可对不同的工作环境是用不同的工作环境，若某项无设定，即使用上一层设置。文件夹设置即为项目设置，将一个文件夹当成一个项目，对同一个工作环境下的不同项目，使用不同的设置，若某项无设定，即使用上一层设置。如何新建一个工作区大家应该都发现了，文件中没有“新建工作区”的选项。打开文件会看到“将工作区另存为…”选项，这就代替了“新建工作区”，再不打开任何工作区、文件夹及文件的清空下，这个选项都可以使用。如果在打开的文件夹的情况下保存工作区，会自动将此文件夹放入工作区，也建议这样使用。工作区你可以把它想象成一个空间，创建一个有规则的空间进行代码的操作。由于要上传到 git 远程仓库，所以要是你的项目中的.gitignore 文件中将.vscode 忽略了，记得将对应忽略项删除。添加工作区中的配置不同项目可以添加不同的配置，小程序项目中的配置是当然由于小程序使用了 prettier，所以要在根目录下创建.prettierrc 文件，添加以下配置解决与 ESlint 的冲突和小程序格式化问题当我们提交后 git 远端仓库的项目就有.vscode 文件夹存在，当我 clone 项目时就可以使用工作区的格式化配置，前提你的本地用户配置不会太精细导致重复覆盖。","tags":["工具"],"categories":["代码格式化"]},{"title":"VSCode合理配置ESLint+Prettier","url":"/2020/11/27/VSCode合理配置ESLint-Prettier/","content":"当前出现 VSCode 代码格式化无效问题解决方案在 vscode 上配置 Eslint+Prettier安装插件安装 eslint、prettier 插件插件使用这里你可以直接修改 vscode 的 setting.json 文件接下来会有一个 eslint 和 prettierrc 格式化方式冲突的现象解决方案就是修改根目录下的 eslintrc.js 文件中的配置，文件中 extends（规则继承） 的默认配置是standard，这是调用了https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style 中对 JavaScript 的标准样式，所以我们要添加与 prettierrc 的兼容性这样就可以正常的使用我们的代码格式化了","tags":["工具"],"categories":["代码格式化"]},{"title":"css 栅格系统","url":"/2020/11/13/css-栅格系统/","content":"GridCSS 栅格布局中最重要的两个元素是 wrapper（parent） 和 items（children）。wrapper 实际上就是栅格，而 items 就是栅格里面的元素。以下面的代码为例：让这个 div 标签成为栅格，我们只需将他的 display 属性设置为 grid：在我们还未做任何后续操作的时候它看起来是这样的：Columns and rows我们需要为这个容器定义行和列，现在将这个容器分割成两行三列，需要用到 grid-template-row 和 grid-template-column 属性：当我们这样去定义 grid-template-columns 时，我们将得到三列，列长就是我们设置的大小，同理 grid-template-rows 也是一样。于是我们得到下面的结果：为了看清楚他们之间的关系，我们修改下代码再看看结果：会得到以下样式：Item接下来需要了解的是，在栅格系统中的元素是如何放置的。我们创建一个 3*3 的栅格，HTML 仍然使用前面的：会出现：你会发现我们的结果中展示的是 32 的栅格，而我们在 CSS 代码中定义的是 33 的栅格，那是因为我们的容器中只有六个元素，如果我们在 HTML 中定义了 9 个元素，那么结果就会是一个 3*3 的栅格为了重新定位并调整这些元素的大小，我们要对该元素使用 grid-column 和 grid-row 属性上面的代码意图是，我们想让 item1 的起点在第一列并且终止在第四列，也就是说，我们想让它独占一行，下面是运行的结果：前面代码中的 grid-column-end: 4; 可能会让人产生困惑，因为我们实际结果中只得到了三列，但是看看下面的图片就能明白了：当第一个元素占满第一行时，其他的元素将向下顺延。上面那段代码其实还有一种更简单的写法：接下来我们来做一些更复杂一点的操作：","tags":["HTML5"],"categories":["css"]},{"title":"行内元素margin、padding无效原因","url":"/2020/10/30/行内元素margin、padding无效原因/","content":"行内元素：可以一行存在多个标签，对宽高属性值不生效，完全靠内容撑开宽高！经过验证后，发现 top/bottom(padding-top/padding-bottom)、top/bottom(margin-top/margin-bottom)这 4 个属性是可以设置的查 w3c 的官方文档并没有找到这个奇葩现象解释（可能我英语比较烂，没找到），后来在一篇老外的文章里找到了答案：While padding can be applied to all sides of an inline element, only left and right padding will have an effect on surrounding content. In the example below, 50px of padding has been applied to all sides of the element. As you can see, it has an affect on the content on each side, but not on content above or below翻译：虽然内嵌元素的所有边距都可以应用，但只有左右边距对周围内容有影响。在下面的例子中，50px 的填充被应用到元素的所有边。可以看到，它对周围的内容有影响。在下面的例子中，50px 的填充被应用到元素的所有边。可以看到，它对每一边的内容都有影响，但对上面或下面的内容没有影响上图中我们设置 margin-top 和 padding-top 的值，但在设置中由于 padding-top 虽然生效但对周围的元素没有造成影响，所以如果颜色为透明就无法看出 padding 效果。marign 因为无法撑起页面高度所以无法直接作用于元素的高度显示。","tags":["HTML5"],"categories":["css"]},{"title":"axios 源码解析","url":"/2020/10/26/axios-源码解析/","tags":["工具"],"categories":["JavaScript"]},{"title":"TypeScript 枚举","url":"/2020/10/15/TypeScript-枚举/","content":"使用枚举使用enum关键字定义对象数字枚举在未设置初始之时，枚举类中的第一个值为 0，其他成员会从 1 开始自动增长（自动加 1）Up 的值为 0， Down 的值为 1 等等。在设置了第一个初始值时，其他成员会从初始值开始自动增长（自动加 1）Up 使用初始化为 1，其余的成员会从 1 开始自动增长。换句话说 Direction.Up 的值为 1，Down 为 2， Left 为 3， Right 为 4。当我们不在乎成员的值时，使用自动增长是可以更加简便的。字符串枚举每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行设置初始化值数字枚举和字符串枚举的区别在于，字符串枚举的值初始化时已经设置，数字枚举的值是运行中提供的，如果要在运行中获取一个数字枚举的值，这是很难读取的，虽然数字枚举中有反向映射，但数字枚举本来就作用于我们不在乎成员值的时候。字符串枚举可以提供一个运行时有意义并可读的值。异构枚举从技术的角度来说，枚举可以混合字符串和数字成员。除非你真的想要利用 JavaScript 运行时的行为，否则我们不建议这样做。计算的和常量成员每个枚举成员都带有一个值，它可以是常量或计算出来的，常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值，所以枚举的值可以是一个常量枚举表达式：一个枚举表达式字面量（主要是字符串字面量或数字字面量）一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）带括号的常量枚举表达式一元运算符 +, -, ~其中之一应用在了常量枚举表达式常量枚举表达式做为二元运算符 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^的操作对象。 若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错。联合枚举与枚举成员的类型存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。 字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为任何字符串字面量（例如： “foo”， “bar”， “baz”）任何数字字面量（例如： 1, 100）应用了一元 -符号的数字字面量（例如： -1, -100）运行时的枚举枚举是在运行时真正存在的对象。在代码编译时，数字枚举的值还没有提供，所以成员的类型不是 number。外部枚举使用关键字declare官方说法：外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常数成员。 对于非常数的外部枚举而言，没有初始化方法时被当做需要经过计算的。我的看法：仅仅会用于编译时的检查，在编译结果中会被删除","tags":["TypeScript基础"],"categories":["TypeScript"]},{"title":"小程序框架","url":"/2020/10/15/小程序框架/","content":"常见框架美团（mpvue）网易（megalo）滴滴（chameleon）微信（KBone）京东（Trao、Trao next）Hbuilder(uni-app)蚂蚁金服（remax）语法分类remaxTaro nextTaro 1/2megalompvueuni-appchameloen语法reactreact类 react （nerve）vuevuevue类 vue厂家蚂蚁金服京东京东网易考拉美团Hbuilder滴滴深入浅出主流的几款小程序跨端框架原理","tags":["框架"],"categories":["小程序"]},{"title":"前端打包工具对比","url":"/2020/09/23/前端打包工具对比/","content":"Npm ScriptNpm Script（ https://docs.npmjs.com/misc/scripts ） 是一个任务执行者。Npm是在安装Node. js时附带的包管理器，Npm Script则是Npm内置的一个功能，允许在package.json文件里面使用scripts字段定义任务：GruntGrunt（ https://gruntjs.com ） 和Npm Script类似，也是一个任务执行者。Grunt有大量现成的插件封装了常见的任务，也能管理任务之间的依赖关系，自动化地执行依赖的任务，每个任务的具体执行代码和依赖关系写在配置文件Gruntfile.js里GulpGulp（ http://gulpjs.com ） 是一个基于流的自动化构建工具。除了可以管理和执行任务，还支持监听文件、读写文件。Gulp被设计得非常简单，只通过下面5种方法就可以支持几乎所有构建场景：通过gulp.task注册一个任务；通过gulp.run执行任务；通过gulp.watch监听文件的变化；通过gulp.src读取文件；通过gulp.dest写文件。Gulp的最大特点是引入了流的概念，同时提供了一系列常用的插件去处理流，流可以在插件之间传递.Fis3Fis3（ http://fis.baidu.com/fis3/ ） 是一个来自百度的优秀国产构建工具。相对于Grunt、Gulp这些只提供了基本功能的工具，Fis3集成了Web开发中的常用构建功能，如下所述。读写文件：通过fis.match读文件，release配置文件的输出路径。资源定位：解析文件之间的依赖关系和文件位置。文件指纹：在通过useHash配置输出文件时为文件URL加上md5戳，来优化浏览器的缓存。文件编译：通过parser配置文件解析器做文件转换，例如将ES6编译成ES5。压缩资源：通过optimizer配置代码压缩方法。图片合并：通过spriter配置合并CSS里导入的图片到一个文件中，来减少HTTP请求数。WebpackWebpack（ https://webpack.js.org ） 是一个打包模块化JavaScript的工具，在Webpack里一切文件皆模块，通过Loader转换文件，通过Plugin注入钩子，最后输出由多个模块组合成的文件。Webpack专注于构建模块化项目。Webpack具有很大的灵活性，能配置处理文件的方式。Webpack的优点是：专注于处理模块化的项目，能做到开箱即用、一步到位；可通过Plugin扩展，完整好用又不失灵活；使用场景不局限于Web开发；社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展；良好的开发体验。Webpack的缺点是只能用于采用模块化开发的项目。RollupRollup（ https://rollupjs.org ） 是一个和Webpack很类似但专注于ES6的模块打包工具。它的亮点在于，能针对ES6源码进行Tree Shaking，以去除那些已被定义但没被使用的代码并进行Scope Hoisting，以减小输出文件的大小和提升运行性能。然而Rollup的这些亮点随后就被Webpack模仿和实现。由于Rollup的使用方法和Webpack差不多，所以这里就不详细介绍如何使用Rollup了，而是详细说明它们的差别：Rollup是在Webpack流行后出现的替代品；Rollup生态链还不完善，体验不如Webpack；Rollup的功能不如Webpack完善，但其配置和使用更简单；Rollup不支持Code Spliting，但好处是在打包出来的代码中没有Webpack那段模块的加载、执行和缓存的代码。Rollup在用于打包JavaScript库时比Webpack更有优势，因为其打包出来的代码更小、更快。但它的功能不够完善，在很多场景下都找不到现成的解决方案。","tags":["工具"],"categories":["包管理工具"]},{"title":"JavaScript 报错类型","url":"/2020/09/21/JavaScript-报错类型/","content":"js 报错类型（6 种错误类型）js 中的控制台的报错信息主要分为两大类，第一类是语法错误，这一类错误在预解析的过程中如果遇到，就会导致整个 JS 文件都无法执行。另一类错误错误统称为异常，这一类的错误出现的那一行之后的代码无法执行，但在那一行之前的代码不会受到影响。SyntaxError(语法错误)ReferenceError（引用错误）我的理解：这玩意压根就不存在比如：TypeError（类型错误）我的理解：瞎几把调用比如：RangeError（范围错误）我的理解:你那玩意过界了EvalError（非法调用 eval()）我的理解: 要盯紧这货URIError（URI 不合法）我的理解：瞎几把乱写","tags":["JavaScript基础"],"categories":["JavaScript"]},{"title":"React Hooks自实现","url":"/2020/09/07/React-Hooks自实现/","content":"了解 useReduceruseReducer 是 React16.8.0 中为数不多由官方提供的之一。它接受一个 ，以及一个初始的应用程序状态，然后返回当前应用程序的状态，和一个调度函数（dispatch）。一个简单的例子：从 useState 开始","tags":["React"],"categories":["JavaScript"]},{"title":"TypeScript 泛型","url":"/2020/09/07/TypeScript-泛型/","content":"泛型的使用主要在于它的重用性，当一个组件可以使用多种类型的数据来使用时，这个组件就拥有很高的复用性，这时就可以用泛型来代替使用数据，这在创建大型系统时为我们提供了十分灵活的功能。泛型基础使用设置泛型类似于接口中规范了使用参数的类型，限制了函数中参数类型的使用。使用泛型变量使用泛型可以用变量代替泛型声明，变量可以代表任意数据类型，类似于使用泛型声明为 any 类型，不过由于是变量所以不能使用类型中的指定函数。泛型类型泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样,我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。泛型约束将泛型变量继承我们的约束条件，泛型中就有的传输参数的限制，当我们使用泛型定义时就要遵守规则。约束条件可以使接口定义在泛型里使用类类型使用原型属性推断并约束构造函数与类实例的关系","tags":["TypeScript基础"],"categories":["TypeScript"]},{"title":"TypeScript 接口","url":"/2020/08/20/TypeScript-接口/","content":"TypeScript 里，接口的作用就是为这些类型定义和为你的代码或第三方代码定义规范基础使用属性可选属性接口定义的可选属性，就是在属性名“：”前加“？”，属性就成了非必需的，这样定义的属性可以不进行默认传值。只读属性接口定义的只读属性，只能读取该属性属性检查即使接口中使用了可选属性，但只是意味着接口实例里可以没有这个属性，并不意味着可以多出其他属性，检查是否有不在接口定义中的属性，就是额外的属性检查。函数类型除了描述带有属性的普通对象外，接口也可以描述函数类型。可索引的类型TypeScript 支持两种索引签名：字符串和数字，可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型，当你定义了 string 类型的对象索引并确定了索引返回值，其他的索引返回值就已经确定，因为当其他索引转换为 JavaScript 时都会转为 string。类类型子类限时父接口时，可以显示父接口的方法。当一个类实现了一个接口时，只对其实例部分进行类型检查，构造函数属于静态部分，不进行属性检查当用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误继承接口可以多继承接口，当接口继承父接口时，子接口就具备父接口的属性或方法多继承混合使用混合可以使一个对象拥有多种使用方式，可以作为函数使用也可以作为对象使用继承类当接口继承了一个类类型时，它会继承类的成员但不包括其实现，接口同样会继承到类的 private 和 protected 成员。","tags":["TypeScript基础"],"categories":["TypeScript"]},{"title":"React 组合vs继承","url":"/2020/08/20/React-组合vs继承/","content":"有些组件无法提前知晓它们子组件的具体内容，所以我们建议这些组件使用一个特殊的 children prop 来将他们的子组件传递到渲染结果中：使得使用组件时，可以将任意组件作为子组件传递给它们。使用这种组件的方法，类似于我们 slot 的使用，在父组件中嵌入子组件，父组件中就可以通过 prop children 获取子组件的内容。不过如果子组件要进行操作，不需要通过父组件调用函数，组件在嵌入的地方调用指定函数。","tags":["React"],"categories":["JavaScript"]},{"title":"TypeScript 类型","url":"/2020/08/17/TypeScript-类型/","tags":["TypeScript基础"],"categories":["TypeScript"]},{"title":"Android手机适配","url":"/2020/08/17/Android手机适配/","content":"UI 设计图推荐 1 倍效果图，即采用 720360 大小：一倍图：720360二倍图：1280720三倍图：19201080采用一倍图的主要原因是因为 1px=1dp,可以直接使用 px 值设置尺寸屏幕各项参数手机像素（px）：一个小黑点（组成屏幕显示的一个个点）就是像素；手机尺寸：屏幕对角线的长度；手机分辨率：整个屏幕一共有多少个点（像素）像素密度（dpi）:每英寸中的像素点数（假如设备分辨率为 320*240，屏幕长 2 英寸宽 1.5 英寸，dpi=320/2 = 240/1.5 =160）;对应 DisplayMetrics 类中属性 densityDpi 的值;当然这种宽和高的 dpi 都相同的情况现在已经很少见，像素密度(dpi)、屏幕尺寸、分辨率三者关系：举例说明：屏幕分辨率为：1920*1080，屏幕尺寸为 5 吋的话，那么 dpi 为 440：密度（density）：每平方英寸中的像素数（density = dpi / 160 ）；对应于 DisplayMetrics 类中属性 density 的值；可用于 px 与 px 与 dip 的互相转换 ：dp = px / density （所以具体换算就是 1dp = density px）；720P,和 1080P 的手机，dpi 是不同的，这也就意味着，不同的分辨率中，1dp 对应不同数量的 px(720P 中，1dp=2px，1080P 中 1dp=3px)。设备独立像素（dp、dip）：不同设备有不同的显示效果，不依赖像素（dp = px / density = px / (dpi / 160) ）dpi（像素密度）为 160 的设备上 1dp = 1px。放大像素（sp）：用于字体显示；dp 转 px、px 转 dp：屏幕适配可以通过手机的分辨率设置不同的尺寸设置文件里面内容是以 dip 为多少 px 设置，例如：","tags":["App应用"],"categories":["Java"]},{"title":"Andorid跳转Flutter页面","url":"/2020/08/17/Andorid跳转Flutter页面/","content":"flutter 页面配置创建 flutter 项目打开 Andorid 项目目录Andorid 页面配置接下来由于 Andorid studio 的项目本地配置信息与你 flutter 生成的 Andorid 项目配置信息不符就会有接下来的一些问题：所以这时候我们需要 build 我的项目，查看项目中存在什么问题修改配置产生这种问题的原因是就是因为 flutter 的 Andorid 项目配置与本地配置不兼容将 gradle 文件里的配置改成本地项目的版本改为以上是我的本地配置，不一定符合你们的本地配置，想看自己本地配置可以新建一个项目或者查看以前项目的配置将 APP 中的 gradle 文件的中的配置改成对应版本改为关联 flutter 页面修改完成后虽然可以进行运行，但会报一下错误这是要页面主题设置主题，请修改 APP 中的 AndoridMainifest.xml 文件就完成了","tags":["App应用"],"categories":["Java"]},{"title":"Sharedb","url":"/2020/06/19/Sharedb/","content":"ShareDBshareDB是基于 JSON 文档转换（OT）的实时数据库后端。它是 DerbyJSWeb 应用程序框架的实时后端。ImmortalDBImmortalDB 是在浏览器中存储持久键值数据的最佳方法。保存到 ImmortalDB 的数据被冗余地存储在 Cookies，IndexedDB 和 localStorage 中，并且如果其中的任何数据被删除或损坏，它们将不断进行自我修复。","tags":["HTML5"],"categories":["JavaScript"]},{"title":"JavaScript好用还未火的注解@Decorator","url":"/2020/06/03/JavaScript注解/","content":"Decorator 使用修饰器（Decorator）是一个函数，用来修改类的行为Babel 支持在使用之前需要先下载 babel 插件修改配置 ( 我用的是 webpack,所有只要在 webpack.config.js 的配置中加上这句话就行 )Class Decorator修饰类就相当于对类进行了一次封装，重新封装的类拥有了指定的函数或执行了指定操作。method Decorator装饰器第一个参数是类的原型对象,第二个参数是所要装饰的属性名,第三个参数是该属性的描述对象descriptor 对象{value：specifiedFunction,// 置换调用enumerable: false, // 是否可以枚举（for in 循环能否遍历的到）configurable: true, // 是否可以配置（是否可以用 delete 删除）writable: true // 是否可以修改（为 false 的时候，只是修改没起作用，不会报错）}修饰函数相当于对指定函数添加了响应事件、回调函数、监听事件。property Decorator修饰属性相当于对指定属性添加或者修改了属性对象的访问器属性装饰类原理装饰一个类的属性ES6 中的类实际上就是一个语法糖，本质上是构造函数，类的属性的定义使用的是 Object.defineProperty() 用一个简单的栗子来理解如下：接收的参数和作用于类的属性的时候装饰器函数的接收的参数很像。本质上也就是说装饰器在作用于类的属性的时候，实际上是通过 Object.defineProperty 来对原有的 descriptor 进行封装","tags":["JavaScript基础"],"categories":["JavaScript"]},{"title":"内联缓存","url":"/2020/05/25/内联缓存/","content":"内联缓存什么是内联缓存首先内联缓存(后面称 IC)也并不是 V8 首创，这项技术也很古老，最初是应用在 Smalltalk 虚拟机上。IC 的原理简单来说就是在运动过程中，收集一些数据信息，将这部分信息缓存起来然后在再次执行的时候可以直接利用这些信息，有效的节省了再次获取这些信息的消耗，从而提高性能。内联缓存是怎么运行的我们可以通过分析一段字节码的运行来看一下内联缓存的运作，如果不了解字节码执行的同学可以先看 V8 引擎详解——字节码是如何执行的先来了解一下。先来看下面一段代码将 function 转成字节码的结构如图：我们分析一下这段字节码(本文重点在于 IC 所以会侧重于涉及 IC 部分)：进入函数先进行栈的检查，然后会将小数字 4 存入累加器。将累加器的值传给a0[0](obj.y),同时将a00的信息缓存到反馈向量表中的第 0 个slot（插槽）中。加载 a01 的值到累加器中同时将 a01的信息缓存到 反馈向量 表中的第 2 个 slot（插槽）中。将累加器中的值加 2，将结果值缓存到反馈向量 表中的第 4 个 slot（插槽）中，然后将累加器中的值赋予到 a01 ，并将信息缓存到反馈向量 表中的第 5 个 slot（插槽）中。最后当我们将 obj.x 中的值直接通过缓存取出到累加器中并将累加器中的值返回。运行过程并不复杂，本质上就是标记一些调用点，然后为他们分配一个插槽缓存起来，当再次调用的时候直接通过缓存获取值。内联缓存的单态与多态事实上我们在调用函数的时候，可以通过缓存信息提高函数的执行效率，但是前提是我们传参的结构是固定的，那如果传递传参数的结构不是固定的内联缓存要如何处理呢？这个就涉及到我们开篇的那个问题了，回到代码来看：这段代码中的func调用的是固定的结构 obj0={x:1,y:2,z:3},所以可以通过内联缓存加速在执行上效率大大提高。但是第二段代码中：func调用的 obj2 每次执行结构都是变化的（i 的值一直在变），那么 v8 是如何处理的这里面就涉及到了多态内联缓存（Ploymorphic Inline Cache）也就是PIC,所谓的 PIC 就是在同一个 Slot 位置上，不仅只缓存一份数据如图：第一次执行函数的时候，v8 会将对象的一些信息记录到 slot 中，第二次执行函数会将第一次记录的信息和第二次的信息进行比较，如果相同直接调用，如果不同会将这部分信息记录在同一个位置。依次类推一个 slot 会记录多份信息（当然也是有一定数量限制的）。 同一个 slot 记录多个信息的情况就可以称之为 PIC 多态内联缓存，而多态内联缓存可能会进行多次的比较操作，自然性能上不如单态内联缓存，也就是为什么开篇中第二段函数执行的比第一段来的慢。","tags":["HTML5"],"categories":["V8引擎"]},{"title":"你可能还不知的 CSS 好用的属性","url":"/2020/05/11/你可能还不知的-CSS-好用的属性/","content":"在这篇文章中，向你介绍了几个比较少见且好用的 CSS 属性，希望对你有所帮助writing-modewriting-mode属性定义了文本水平或者垂直排布以及在哪块级元素中文本的进行方向。为整个文档设置书时，应在根元素上设置它（对于 HTML 文档应该在 HTML 元素上设置）。它采用以下值之一horizontal-tb (default) | vertical-rl | vertical-lr。horizontal-tb：对于左对齐(ltr)脚本，内容从左到右水平流动。对于右对齐(rtr)脚本，内容从右到左水平流动。下一水平行位于上一行下方。vertical-rl：对于左对齐(ltr)脚本，内容从上到下垂直流动，下一垂直行位于上一行左侧。对于右对齐(rtr)脚本，内容从下到上垂直流动，下一垂直行位于上一行右侧。vertical-lr：对于左对齐(ltr)脚本，内容从上到下垂直流动，下一垂直行位于上一行右侧。对于右对齐(rtr)脚本，内容从上到下垂直流动，下一垂直位于上一行左侧。font-variant-numericfont-variant-numericCSS 属性控制数字，分数和序号标记的替代字形的使用。它采用余下这些值之一：normal | ordinal | slashed-zero | lining-nums | oldstyle-nums | proportional-nums | tabular-nums | diagonal-fractions | stacked-fractions此属性对于设置数字样式很有用。根据情况，你可能希望显示老式的数字或带有斜杠的零，对于这些情况，font-variant-numeric很有用。请注意，font-variant-numeric是font-feature-setting组属性的一部分。user-select每当我们有不想让用户选择的文本，或者相反，如果发生了双击或上下文单击，希望选择所有文本时，user-select属性将非常有用。none:不允许选中all:选中全部text:可以选择文本element：可以选择文本，但选择范围受元素边界的约束shape-outsideshape-outside的 CSS 属性定义了一个可以是非矩形的形状，相邻的内联内容应该围绕该形状进行包装。默认情况下，内联内容包围其边边距框；\bshape-outside提供了一种自定义此包装的方法，可以将文本包装在复杂对象周围而不是简单的框中。它采用与clip-path相同的值。clip-path定义用户如何查看元素，shape-outside定义其他 HTML 元素如何查看元素。background-clipbackgroundclip CSS 属性设置元素的背景是否扩展到其border 、padding 或content 框之下background-attachmentbackground-attachment属性设置背景图像是否固定或者随着页面的其余部分滚动。scroll(default)：背景图像会随着页面其余部分的滚动而移动。fixed：当页面的其余部分滚动时，背景图像不会移动。inherit：规定应该从父元素继承属性设置值。outlineoutline是绘制于元素周围的一条线，位于边框边缘的外围，可以起到突出元素的作用。outline中有设置所有的轮廓属性，属性如下：outline-color、outline-style、outline-width。outline-color：设置轮廓颜色outline-style：设置轮廓样式outline-width：设置轮廓的宽度outline-style：dotted:点状dashed:虚线solid: 实线double:双线groove: 凹槽(3d)ridge: 山脊(3d)inset: 内凹(3d)outset: 外凸(3d)","tags":["HTML5"],"categories":["css"]},{"title":"本地存储的localStorage和sessionStorage","url":"/2020/05/06/本地存储的localStorage和sessionStorage/","content":"localStorage(本地存储)localStorage 是只读的。数据存储也是跨浏览器会话。数据储存在 localStorage 是无期限的。常用的四个 API 也很简单 ：但需要注意的是，在移动设备上的浏览器或各 Native App 用到的 WebView 里，localStorage 都是不可靠的，可能会因为各种原因（比如说退出 App、网络切换、内存不足等原因）被清空。sessionStorage(会话存储)当页面被关闭时,数据存储在 sessionStorage 会被清除localStorage 一些不为人知的方法localStorage.hasOwnProperty() 检查 localStorage 中存储的数据里是否保存某个值storage 事件当存储数据发生变化时，会触发 storage 事件。值得特别注意的是，该事件不在导致数据变化的当前页面触发。如果浏览器同时打开一个域名下面的多个页面，当其中的一个页面改变 sessionStorage 或 localStorage 的数据时，其他所有页面的 storage 事件会被触发，而原始页面并不触发 storage 事件。可以通过这种机制，实现多个窗口之间的通信。（当然 ie 这个特例除外，它包含自己本事也会触发 storage 事件）。event.key 属性：属性值为在 session 或 localStorage 中被修改的数据键值。event.oldValue 属性：属性值为在 sessionStorage 或 localStorage 中被修改的值。event.newValue 属性：属性值为在 sessionStorage 或 localStorage 中被修改后的值event.url 属性：属性值为修改 sessionStorage 或 localStorage 中值的页面的 URL 地址event.storageArea 属性 : 属性值为被变动的 sessionStorage 对象或 localStorage 对象原理在 HTML5 中，本地储存是一个 window 的属性，包括 localStrong 和 sessionStrong。localStrong 和 sessionStrong 都是储存在 window 里的 strong 实例对象，我们对 Window.sessionStorage 和 Window.localStorage 属性使用其实就是改变了 window 本地存储的对象。Window 对象表示一个浏览器窗口或一个框架。在客户端 JavaScript 中，Window 对象是全局对象，所有的表达式都在当前的环境中计算。","tags":["HTML5"],"categories":["JavaScript"]},{"title":"数组的push、unshift、pop、shift方法实现","url":"/2020/04/30/数组的push、unshift、pop、shift方法实现/","content":"尾部添加(push)push()函数将一个或者多个元素添加到数组的末尾，并返回该数组的新长度从解释中可以看出，push 函数只要将要添加的元素依次放到数组的最后即可，不会改变原有数组元素的索引。所以循环参数列表，将新元素依次放到数组的最后即可。头部添加(unshift)unshift()函数将将一个或者多个元素添加到数组的开头，并返回该数组的新长度（该函数修改原有数组）向数组的头部添加元素，数组的长度也会发生变化，但不像尾部添加的操作，数组原有元素索引不改变。做头部添加的操作，需要将原有元素的索引向左移动。例如只添加一位，则需要将数组的每个元素的索引依次向右移一位，假设原来数组长度是 4，头部添加一个元素，长度变为 5。所以现在就变成：array.length = 5,而目前array[5-1]是最后一个元素，现在由于依次往后移动，所以，array[5-1]必须是最后一个元素所以我们可以从数组的最后一位的下一位往前循环，将 array[i]赋值为 array[i-1]循环到 1 停，将 array 的第 0 项赋值为需要添加的值。过程如下具体代码实现：但上面的代码只实现了一个元素的头部添加，unshift 方法支持添加多个元素。例如：针对这样的情况，需要知道传入了几个参数，可以从 arguments 对象入手，思路还是上面的思路：先以最后生成的数组长度为基准从后往前循环，依次移动元素，然后将新元素依次放到数组的头部新数组的长度等于原数组的长度 + 参数的个数，从后往前循环，将原数组的最后一位，移动到新数组的最后一位，因为需要在头部插入数量为入参个数的元素，所以循环的起点为原数组的长度 + 参数的个数，循环的终点为入参的个数。但由于索引总是比长度少一位，所以起点和终点都需要减 1。现在可以先把循环移动的逻辑写出来再思考一下，由于上一步已经移动完了，数组头部的位置已经空出来了，第二步是有几个参数就要插入几个元素。所以现在只需要循环插入就好：尾部删除 (pop)pop()函数将删除arrayObject的最后一个元素，把数组长度减1，并且返回它删除的元素的值，如果数组已经为空，则pop()不改变数组，并返回undefined值这个很好实现，按照定义一步一步做就可以。首先，记录下最后一个元素，便于返回，之后从数组中删除最后一个元素，将其指向 null 释放掉，然后将数组的长度减 1，最后判断一下是否为空数组。头部删除（shift）shift()函数用于把数组的第一个元素从其中删除，并返回第一个元素的值头部删除，会改变原有数组元素的索引，也就是将未被删除的元素索引都往左移一位，首先要将被删除的元素记录下来便于返回，之后将数组第一个元素指向 null，最后循环数组，移动索引。","tags":["算法"],"categories":["JavaScript"]},{"title":"BFC(Block Fommatting context)","url":"/2020/04/23/BFC-Block-Fommatting-context/","content":"什么是 BFC?W3C 对 BFC 的定义如下： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及 overflow 值不为”visiable”的块级盒子，都会为他们的内容创建新的 BFC（Block Fromatting Context， 即块级格式上下文）。块格式化上下文（Block Formatting Context，BFC） 是 Web 页面的可视化 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。FC 是 formatting context 的首字母缩写，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。触发条件一个 HTML 元素要创建 BFC，则满足下列的任意一个或多个条件即可： 下列方式会创建块格式化上下文：根元素()浮动元素（元素的 float 不是 none）绝对定位元素（元素的 position 为 absolute 或 fixed）行内块元素（元素的 display 为 inline-block）表格单元格（元素的 display 为 table-cell，HTML 表格单元格默认为该值）表格标题（元素的 display 为 table-caption，HTML 表格标题默认为该值）匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是 HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table）overflow 值不为 visible 的块元素 -弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）网格元素（display 为 grid 或 inline-grid 元素的直接子元素） 等等。BFC 渲染规则BFC 垂直方向边距重叠BFC 的区域不会与浮动元素的 box 重叠BFC 是一个独立的容器，外面的元素不会影响里面的元素计算 BFC 高度的时候浮动元素也会参与计算应用场景防止浮动导致父元素高度塌陷现有如下页面代码:接下来将 inner 元素设为浮动:但如果我们对父元素设置 BFC 后, 这样的问题就解决了:避免外边距折叠两个块同一个 BFC 会造成外边距折叠，但如果对这两个块分别设置 BFC，那么边距重叠的问题就不存在了。现有代码如下:此时三个元素的上下间隔都是 10px, 因为三个元素同属于一个 BFC。 现在我们做如下操作:style 增加:效果如下:可以明显地看到间隔变大了，而且是原来的两倍，符合我们的预期。相关链接https://juejin.im/post/5909db2fda2f60005d2093db","tags":["视图"],"categories":["HTML5"]}]